
================================================================================
File: C:\Users\admloc\Desktop\KWAB\PetMindReader\src\file-scanner.py
================================================================================

import os
import mimetypes

def is_text_file(filename):
    """
    Check if a file is likely to be a text file based on its mime type
    or common code file extensions
    """
    # Common code file extensions
    code_extensions = {
        '.py', '.js', '.java', '.cpp', '.c', '.h', '.cs', '.php',
        '.rb', '.swift', '.kt', '.go', '.rs', '.ts', '.html', '.css',
        '.sql', '.sh', '.bat', '.ps1', '.txt', '.md', '.json', '.xml',
        '.yaml', '.yml', '.ini', '.conf', '.cfg', '.tsx'
    }
    
    # Check extension
    ext = os.path.splitext(filename)[1].lower()
    if ext in code_extensions:
        return True
        
    # Check mime type
    mime_type, _ = mimetypes.guess_type(filename)
    return mime_type and mime_type.startswith('text/')

def scan_directory(output_file):
    """
    Recursively scan the current directory and its subdirectories
    for text/code files and write their contents to the output file
    """
    with open(output_file, 'w', encoding='utf-8') as out:
        for root, _, files in os.walk('.'):
            for file in files:
                file_path = os.path.join(root, file)
                
                # Skip the output file itself
                if os.path.abspath(file_path) == os.path.abspath(output_file):
                    continue
                    
                if is_text_file(file_path):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            # Write file path with clear separator
                            out.write(f"\n{'='*80}\n")
                            out.write(f"File: {os.path.abspath(file_path)}\n")
                            out.write(f"{'='*80}\n\n")
                            
                            # Write file contents
                            out.write(f.read())
                            out.write('\n')
                    except Exception as e:
                        out.write(f"Error reading file {file_path}: {str(e)}\n")

if __name__ == '__main__':
    output_file = 'code_contents.txt'
    print(f"Scanning directory and writing contents to {output_file}...")
    scan_directory(output_file)
    print("Scan complete!")


================================================================================
File: C:\Users\admloc\Desktop\KWAB\PetMindReader\src\components\LoadingScreen.tsx
================================================================================

// src/components/LoadingScreen.tsx
import React from 'react';
import { View, ActivityIndicator, StyleSheet } from 'react-native';

function LoadingScreen(): JSX.Element {
  return (
    <View style={styles.container}>
      <ActivityIndicator size="large" color="#007AFF" />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
  },
});

export default LoadingScreen;

================================================================================
File: C:\Users\admloc\Desktop\KWAB\PetMindReader\src\contexts\AppContext.tsx
================================================================================

// src/contexts/AppContext.tsx
import React, { createContext, useContext, useReducer, useEffect, ReactNode, useState } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Types
export interface Pet {
  id: string;
  name: string;
  type: string;
  breed?: string;
  traits?: {
    suggested: string[];
    custom: string[];
  };
  quirks?: string;
  favoriteThings?: string;
}

interface User {
  id: string;
  name: string;
  familyMembers?: string[];
}

interface Photo {
  uri: string;
  base64?: string;
  width?: number;
  height?: number;
}

interface AppState {
  user: User | null;
  pets: Pet[];
  currentPhoto: Photo | null;
  currentThought: string | null;
}

type AppContextType = {
  state: AppState;
  actions: {
    setUser: (user: User) => void;
    addPet: (pet: Pet) => void;
    updatePet: (pet: Pet) => void;
    deletePet: (petId: string) => void;
    setCurrentPhoto: (photo: Photo) => void;
    setCurrentThought: (thought: string) => void;
  };
};

// Initial State & Storage Keys
const initialState: AppState = {
  user: null,
  pets: [],
  currentPhoto: null,
  currentThought: null,
};

const STORAGE_KEYS = {
  USER: '@pet_thoughts_user',
  PETS: '@pet_thoughts_pets',
};

// Action Types
enum ActionTypes {
  SET_USER = 'SET_USER',
  ADD_PET = 'ADD_PET',
  UPDATE_PET = 'UPDATE_PET',
  DELETE_PET = 'DELETE_PET',
  SET_CURRENT_PHOTO = 'SET_CURRENT_PHOTO',
  SET_CURRENT_THOUGHT = 'SET_CURRENT_THOUGHT',
}

type Action =
  | { type: ActionTypes.SET_USER; payload: User }
  | { type: ActionTypes.ADD_PET; payload: Pet }
  | { type: ActionTypes.UPDATE_PET; payload: Pet }
  | { type: ActionTypes.DELETE_PET; payload: string }
  | { type: ActionTypes.SET_CURRENT_PHOTO; payload: Photo }
  | { type: ActionTypes.SET_CURRENT_THOUGHT; payload: string };

const initializeState = async (): Promise<AppState> => {
  try {
    const [userData, petsData] = await Promise.all([
      AsyncStorage.getItem(STORAGE_KEYS.USER),
      AsyncStorage.getItem(STORAGE_KEYS.PETS),
    ]);

    return {
      ...initialState,
      user: userData ? JSON.parse(userData) : null,
      pets: petsData ? JSON.parse(petsData) : [],
    };
  } catch (error) {
    console.error('Error loading initial state:', error);
    return initialState;
  }
};

// Reducer
function appReducer(state: AppState, action: Action): AppState {
  let newState: AppState;

  switch (action.type) {
    case ActionTypes.SET_USER:
      newState = {
        ...state,
        user: action.payload,
      };
      AsyncStorage.setItem(STORAGE_KEYS.USER, JSON.stringify(action.payload));
      return newState;

    case ActionTypes.ADD_PET:
      console.log('ADD_PET action received:', action.payload);
      console.log('Current pets:', state.pets);
      newState = {
        ...state,
        pets: [...state.pets, action.payload],
      };
      console.log('New pets array:', newState.pets);
      AsyncStorage.setItem(STORAGE_KEYS.PETS, JSON.stringify(newState.pets));
      return newState;

    case ActionTypes.UPDATE_PET:
      newState = {
        ...state,
        pets: state.pets.map(pet =>
          pet.id === action.payload.id ? action.payload : pet
        ),
      };
      AsyncStorage.setItem(STORAGE_KEYS.PETS, JSON.stringify(newState.pets));
      return newState;

    case ActionTypes.DELETE_PET:
      newState = {
        ...state,
        pets: state.pets.filter(pet => pet.id !== action.payload),
      };
      AsyncStorage.setItem(STORAGE_KEYS.PETS, JSON.stringify(newState.pets));
      return newState;

    case ActionTypes.SET_CURRENT_PHOTO:
      return {
        ...state,
        currentPhoto: action.payload,
      };

    case ActionTypes.SET_CURRENT_THOUGHT:
      return {
        ...state,
        currentThought: action.payload,
      };

    default:
      return state;
  }
}

// Context
const AppContext = createContext<AppContextType>({
  state: initialState,
  actions: {
    setUser: () => {},
    addPet: () => {},
    updatePet: () => {},
    deletePet: () => {},
    setCurrentPhoto: () => {},
    setCurrentThought: () => {},
  },
});

// Provider Component
interface AppProviderProps {
  children: ReactNode;
}

export function AppProvider({ children }: AppProviderProps) {
  const [state, dispatch] = useReducer(appReducer, initialState);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const loadInitialState = async () => {
      const initializedState = await initializeState();
      if (initializedState.user) {
        dispatch({ type: ActionTypes.SET_USER, payload: initializedState.user });
      }
      if (initializedState.pets.length > 0) {
        initializedState.pets.forEach(pet => {
          dispatch({ type: ActionTypes.ADD_PET, payload: pet });
        });
      }
      setIsLoading(false);
    };

    loadInitialState();
  }, []);

  if (isLoading) {
    return null; // or return a loading component
  }

  const setUser = (user: User) => {
    dispatch({ type: ActionTypes.SET_USER, payload: user });
  };

  const addPet = (pet: Pet) => {
    dispatch({ type: ActionTypes.ADD_PET, payload: pet });
  };

  const updatePet = (pet: Pet) => {
    dispatch({ type: ActionTypes.UPDATE_PET, payload: pet });
  };

  const deletePet = (petId: string) => {
    dispatch({ type: ActionTypes.DELETE_PET, payload: petId });
  };

  const setCurrentPhoto = (photo: Photo) => {
    dispatch({ type: ActionTypes.SET_CURRENT_PHOTO, payload: photo });
  };

  const setCurrentThought = (thought: string) => {
    dispatch({ type: ActionTypes.SET_CURRENT_THOUGHT, payload: thought });
  };

  const value = {
    state,
    actions: {
      setUser,
      addPet,
      updatePet,
      deletePet,
      setCurrentPhoto,
      setCurrentThought,
    },
  };

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

// Hook
export function useApp(): AppContextType {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useApp must be used within an AppProvider');
  }
  return context;
}

================================================================================
File: C:\Users\admloc\Desktop\KWAB\PetMindReader\src\navigation\index.tsx
================================================================================

// src/navigation/index.tsx
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';

// Screens
import HomeScreen from '../screens/HomeScreen';
import PhotoPreviewScreen from '../screens/PhotoPreviewScreen';
import PhotoResultScreen from '../screens/PhotoResultScreen';
import YourPetsWorldScreen from '../screens/YourPetsWorldScreen';
import WelcomeScreen from '../screens/onboarding/WelcomeScreen';
import FamilyContextScreen from '../screens/onboarding/FamilyContextScreen';
import PetManagementScreen from '../screens/onboarding/PetManagementScreen';
import PetDetailsScreen from '../screens/onboarding/PetDetailsScreen';

// Types
export type MainStackParamList = {
  Home: undefined;
  YourPetsWorld: undefined;
  PhotoPreview: {
    photoUri: string;
    base64?: string;
    width?: number;
    height?: number;
  };
  PhotoResult: {
    photoUri: string;
    base64?: string;
    width?: number;
    height?: number;
  };
  PetManagement: {
    fromOnboarding?: boolean;  // Add this line
  } | undefined;  // Make it optional
  PetDetails: {
    petId: string | null;
    fromOnboarding?: boolean;
  };
  FamilyContext: undefined;
};

export type OnboardingStackParamList = {
  Welcome: undefined;
  FamilyContext: undefined;
  PetManagement: {
    fromOnboarding?: boolean;  // Add this line
  } | undefined;  // Make it optional
  PetDetails: {
    petId: string | null;
    fromOnboarding?: boolean;
  };
};

const MainStack = createNativeStackNavigator<MainStackParamList>();
const OnboardingStack = createNativeStackNavigator<OnboardingStackParamList>();

// Separate navigator for main app flow
function MainNavigator() {
  return (
    <MainStack.Navigator
      screenOptions={{
        headerShown: true,
        headerBackTitle: 'Back',
      }}
    >
      <MainStack.Screen 
        name="Home" 
        component={HomeScreen}
        options={{ headerShown: false }}
      />
      <MainStack.Screen 
        name="YourPetsWorld" 
        component={YourPetsWorldScreen}
        options={{ headerTitle: "Your Pet's World" }}
      />
      <MainStack.Screen 
        name="PetManagement" 
        component={PetManagementScreen}
        options={{ headerTitle: 'Magical Companions' }}
      />
      <MainStack.Screen 
        name="FamilyContext" 
        component={FamilyContextScreen}
        options={{ headerTitle: 'Their Human Circle' }}
      />
      <MainStack.Screen 
        name="PetDetails" 
        component={PetDetailsScreen}
        options={({ route }) => ({
          headerTitle: route.params?.petId ? 'Edit Companion' : 'Add Companion',
        })}
      />
      <MainStack.Screen 
        name="PhotoPreview" 
        component={PhotoPreviewScreen}
        options={{
          headerTitle: '',
          headerTransparent: true,
          headerTintColor: '#fff',
        }}
      />
      <MainStack.Screen 
        name="PhotoResult" 
        component={PhotoResultScreen}
        options={{
          headerTitle: '',
          headerTransparent: true,
          headerTintColor: '#fff',
        }}
      />
    </MainStack.Navigator>
  );
}

// Separate navigator for onboarding flow
function OnboardingNavigator() {
  return (
    <OnboardingStack.Navigator
      screenOptions={{
        headerShown: true,
        headerBackTitle: 'Back',
      }}
    >
      <OnboardingStack.Screen 
        name="Welcome" 
        component={WelcomeScreen}
        options={{ headerShown: false }}
      />
      <OnboardingStack.Screen 
        name="FamilyContext" 
        component={FamilyContextScreen}
        options={{ headerTitle: 'Your Magical Circle' }}
      />
      <OnboardingStack.Screen 
        name="PetManagement" 
        component={PetManagementScreen}
        options={{ headerTitle: 'Your Magical Companions' }}
      />
      <OnboardingStack.Screen 
        name="PetDetails" 
        component={PetDetailsScreen}
        options={({ route }) => ({
          headerTitle: route.params?.petId ? 'Edit Companion' : 'Add Companion',
        })}
      />
    </OnboardingStack.Navigator>
  );
}

// Root navigator that switches between onboarding and main app
const RootStack = createNativeStackNavigator();

type RootNavigatorProps = {
  isOnboarding: boolean;
};

export function RootNavigator({ isOnboarding }: RootNavigatorProps) {
  return (
    <NavigationContainer>
      <RootStack.Navigator screenOptions={{ headerShown: false }}>
        {isOnboarding ? (
          <RootStack.Screen name="OnboardingFlow" component={OnboardingNavigator} />
        ) : (
          <RootStack.Screen name="MainFlow" component={MainNavigator} />
        )}
      </RootStack.Navigator>
    </NavigationContainer>
  );
}

================================================================================
File: C:\Users\admloc\Desktop\KWAB\PetMindReader\src\screens\HomeScreen.tsx
================================================================================

// src/screens/HomeScreen.tsx
import React from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import type { MainStackParamList } from '../navigation';
import { useApp } from '../contexts/AppContext';
import { launchCamera, launchImageLibrary } from 'react-native-image-picker';
import { Camera, Image as ImageIcon } from 'lucide-react-native';

type NavigationProp = NativeStackNavigationProp<MainStackParamList, 'Home'>;

function HomeScreen(): JSX.Element {
  const navigation = useNavigation<NavigationProp>();
  const { actions } = useApp();

  const handleImageSelection = async (type: 'camera' | 'gallery') => {
    try {
      const launch = type === 'camera' ? launchCamera : launchImageLibrary;
      const result = await launch({
        mediaType: 'photo',
        includeBase64: true,
      });

      if (result.assets && result.assets[0]) {
        const photo = {
          uri: result.assets[0].uri || '',
          base64: result.assets[0].base64,
          width: result.assets[0].width,
          height: result.assets[0].height,
        };
        
        actions.setCurrentPhoto(photo);
        
        // Navigate to PhotoPreview screen
        navigation.navigate('PhotoPreview', {
          photoUri: photo.uri,
          base64: photo.base64,
          width: photo.width,
          height: photo.height,
        });
      }
    } catch (error) {
      console.error('Error selecting photo:', error);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Pet Thoughts</Text>
      
      <View style={styles.captureSection}>
        <Text style={styles.sectionTitle}>Capture Magic</Text>
        <View style={styles.captureButtons}>
          <Pressable 
            style={styles.captureButton}
            onPress={() => handleImageSelection('camera')}
          >
            <Camera size={32} color="#fff" />
            <Text style={styles.captureButtonText}>Take Photo</Text>
          </Pressable>
          
          <Pressable 
            style={styles.captureButton}
            onPress={() => handleImageSelection('gallery')}
          >
            <ImageIcon size={32} color="#fff" />
            <Text style={styles.captureButtonText}>Choose Photo</Text>
          </Pressable>
        </View>
      </View>

      <Pressable 
        style={styles.worldButton}
        onPress={() => navigation.navigate('YourPetsWorld')}
      >
        <Text style={styles.worldButtonText}>Enter Your Pet's World</Text>
      </Pressable>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    padding: 20,
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    textAlign: 'center',
    marginTop: 60,
    marginBottom: 40,
    color: '#007AFF',
  },
  captureSection: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 40,
  },
  sectionTitle: {
    fontSize: 24,
    fontWeight: '600',
    marginBottom: 20,
    color: '#333',
  },
  captureButtons: {
    flexDirection: 'row',
    gap: 20,
  },
  captureButton: {
    backgroundColor: '#007AFF',
    padding: 20,
    borderRadius: 16,
    alignItems: 'center',
    width: 150,
    gap: 12,
  },
  captureButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  worldButton: {
    backgroundColor: '#34C759',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
    marginBottom: 40,
  },
  worldButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
});

export default HomeScreen;

================================================================================
File: C:\Users\admloc\Desktop\KWAB\PetMindReader\src\screens\PhotoPreviewScreen.tsx
================================================================================

// src/screens/PhotoPreviewScreen.tsx
import React, { useEffect, useState } from 'react';
import {
  View,
  Image,
  StyleSheet,
  Dimensions,
  Pressable,
  Text,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import type { MainStackParamList } from '../navigation';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';

type NavigationProp = NativeStackNavigationProp<MainStackParamList, 'PhotoPreview'>;

function PhotoPreviewScreen(): JSX.Element {
  const navigation = useNavigation<NavigationProp>();
  const route = useRoute();
  const { photoUri, width, height, base64 } = route.params as MainStackParamList['PhotoPreview'];
  const [imageLayout, setImageLayout] = useState({ width: 0, height: 0 });

  useEffect(() => {
    // Calculate image dimensions to fit screen while maintaining aspect ratio
    if (width && height) {
      const screenWidth = Dimensions.get('window').width;
      const screenHeight = Dimensions.get('window').height;
      const imageRatio = height / width;
      const screenRatio = screenHeight / screenWidth;

      if (imageRatio > screenRatio) {
        const newHeight = screenHeight * 0.8;
        setImageLayout({
          height: newHeight,
          width: newHeight / imageRatio,
        });
      } else {
        const newWidth = screenWidth * 0.9;
        setImageLayout({
          width: newWidth,
          height: newWidth * imageRatio,
        });
      }
    }
  }, [width, height]);

  const handleRevealThoughts = () => {
    navigation.navigate('PhotoResult', {
      photoUri,
      base64,
      width,
      height,
    });
  };

  const handleTryAgain = () => {
    navigation.goBack();
  };

  return (
    <View style={styles.container}>
      <Image
        source={{ uri: photoUri }}
        style={[
          styles.image,
          {
            width: imageLayout.width,
            height: imageLayout.height,
          },
        ]}
      />
      <View style={styles.buttonContainer}>
        <Pressable style={styles.button} onPress={handleRevealThoughts}>
          <Text style={styles.buttonText}>Reveal Thoughts</Text>
        </Pressable>
        <Pressable style={[styles.button, styles.secondaryButton]} onPress={handleTryAgain}>
          <Text style={styles.secondaryButtonText}>Try Another Photo</Text>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000',
    justifyContent: 'center',
    alignItems: 'center',
  },
  image: {
    resizeMode: 'contain',
  },
  buttonContainer: {
    position: 'absolute',
    bottom: 40,
    left: 20,
    right: 20,
    gap: 12,
  },
  button: {
    backgroundColor: '#007AFF',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  secondaryButton: {
    backgroundColor: 'transparent',
    borderWidth: 1,
    borderColor: '#fff',
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
  secondaryButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
});

export default PhotoPreviewScreen;

================================================================================
File: C:\Users\admloc\Desktop\KWAB\PetMindReader\src\screens\PhotoResultScreen.tsx
================================================================================

// src/screens/PhotoResultScreen.tsx
import React, { useEffect, useState, useRef } from 'react';
import {
  View,
  Image,
  StyleSheet,
  Dimensions,
  Animated,
  Platform,
  Text,
  Pressable,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { BlurView } from '@react-native-community/blur';
import { useApp } from '../contexts/AppContext';
import type { MainStackParamList } from '../navigation';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';

type NavigationProp = NativeStackNavigationProp<MainStackParamList, 'PhotoResult'>;

function PhotoResultScreen(): JSX.Element {
  const navigation = useNavigation<NavigationProp>();
  const route = useRoute();
  const { photoUri, width, height } = route.params as MainStackParamList['PhotoResult'];
  const { state } = useApp();
  const [imageLayout, setImageLayout] = useState({ width: 0, height: 0 });
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const thoughtsAnim = useRef(new Animated.Value(0)).current;

  // Placeholder thought - this will be replaced with AI-generated content
  const [thought] = useState(
    "Oh, the things I could tell you about what's going on in my human's head right now... 😏"
  );

  useEffect(() => {
    // Calculate image dimensions to fit screen while maintaining aspect ratio
    if (width && height) {
      const screenWidth = Dimensions.get('window').width;
      const screenHeight = Dimensions.get('window').height;
      const imageRatio = height / width;
      const screenRatio = screenHeight / screenWidth;

      if (imageRatio > screenRatio) {
        const newHeight = screenHeight * 0.8;
        setImageLayout({
          height: newHeight,
          width: newHeight / imageRatio,
        });
      } else {
        const newWidth = screenWidth * 0.9;
        setImageLayout({
          width: newWidth,
          height: newWidth * imageRatio,
        });
      }
    }

    // Start animations
    Animated.sequence([
      // Fade in image
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 1000,
        useNativeDriver: true,
      }),
      // Reveal thoughts
      Animated.timing(thoughtsAnim, {
        toValue: 1,
        duration: 800,
        useNativeDriver: true,
      }),
    ]).start();
  }, [width, height, fadeAnim, thoughtsAnim]);

  const handleTakeAnother = () => {
    navigation.navigate('Home');
  };

  const ThoughtBubble = Platform.select({
    ios: () => (
      <BlurView
        style={[styles.thoughtContainer, { opacity: thoughtsAnim }]}
        blurType="light"
        blurAmount={10}
      >
        <Text style={styles.thoughtText}>{thought}</Text>
      </BlurView>
    ),
    android: () => (
      <Animated.View
        style={[
          styles.thoughtContainer,
          styles.androidBlur,
          { opacity: thoughtsAnim }
        ]}
      >
        <Text style={styles.thoughtText}>{thought}</Text>
      </Animated.View>
    ),
  })!;

  return (
    <View style={styles.container}>
      <Animated.View
        style={[
          styles.imageContainer,
          {
            opacity: fadeAnim,
          },
        ]}
      >
        <Image
          source={{ uri: photoUri }}
          style={[
            styles.image,
            {
              width: imageLayout.width,
              height: imageLayout.height,
            },
          ]}
        />
        <ThoughtBubble />
      </Animated.View>

      <Pressable 
        style={styles.anotherButton}
        onPress={handleTakeAnother}
      >
        <Text style={styles.buttonText}>Capture Another Moment</Text>
      </Pressable>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000',
    justifyContent: 'center',
    alignItems: 'center',
  },
  imageContainer: {
    position: 'relative',
  },
  image: {
    resizeMode: 'contain',
  },
  thoughtContainer: {
    position: 'absolute',
    bottom: 40,
    left: 20,
    right: 20,
    minHeight: 80,
    borderRadius: 20,
    padding: 15,
    justifyContent: 'center',
  },
  androidBlur: {
    backgroundColor: 'rgba(255, 255, 255, 0.8)',
  },
  thoughtText: {
    fontSize: 18,
    color: '#000',
    textAlign: 'center',
    fontStyle: 'italic',
  },
  anotherButton: {
    position: 'absolute',
    bottom: 40,
    left: 20,
    right: 20,
    backgroundColor: '#007AFF',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
});

export default PhotoResultScreen;

================================================================================
File: C:\Users\admloc\Desktop\KWAB\PetMindReader\src\screens\YourPetsWorldScreen.tsx
================================================================================

// src/screens/YourPetsWorldScreen.tsx
import React from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { useApp } from '../contexts/AppContext';
import type { MainStackParamList } from '../navigation';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';

type NavigationProp = NativeStackNavigationProp<MainStackParamList, 'YourPetsWorld'>;

function YourPetsWorldScreen(): JSX.Element {
  const navigation = useNavigation<NavigationProp>();
  const { state } = useApp();
  const { user, pets } = state;

  return (
    <View style={styles.container}>
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Magical Companions</Text>
        <Text style={styles.sectionSubtitle}>
          {pets.length === 0 
            ? "No magical companions yet!" 
            : `${pets.length} magical companion${pets.length > 1 ? 's' : ''}`}
        </Text>
        <Pressable
          style={styles.button}
          onPress={() => navigation.navigate('PetManagement')}
        >
          <Text style={styles.buttonText}>
            {pets.length === 0 ? 'Add Your First Pet' : 'Manage Companions'}
          </Text>
        </Pressable>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Their Human Circle</Text>
        <Text style={styles.sectionSubtitle}>
          {user?.familyMembers?.length 
            ? `${user.familyMembers.length + 1} humans in the circle` 
            : 'Just you in the circle'}
        </Text>
        <Pressable
          style={styles.button}
          onPress={() => navigation.navigate('FamilyContext')}
        >
          <Text style={styles.buttonText}>Manage Circle</Text>
        </Pressable>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    padding: 20,
  },
  section: {
    marginBottom: 40,
    backgroundColor: '#f8f9fa',
    borderRadius: 20,
    padding: 20,
  },
  sectionTitle: {
    fontSize: 24,
    fontWeight: '600',
    marginBottom: 8,
    color: '#007AFF',
  },
  sectionSubtitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 20,
  },
  button: {
    backgroundColor: '#007AFF',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
});

export default YourPetsWorldScreen;

================================================================================
File: C:\Users\admloc\Desktop\KWAB\PetMindReader\src\screens\onboarding\FamilyContextScreen.tsx
================================================================================

// src/screens/onboarding/FamilyContextScreen.tsx
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, StyleSheet, Pressable, ScrollView } from 'react-native';
import { useNavigation, useRoute, RouteProp } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useApp } from '../../contexts/AppContext';
import { MainStackParamList, OnboardingStackParamList } from '../../navigation';

type CombinedParamList = MainStackParamList & OnboardingStackParamList;

type NavigationProp = NativeStackNavigationProp<CombinedParamList, 'FamilyContext'>;
type RouteProps = RouteProp<CombinedParamList, 'FamilyContext'>;

function FamilyContextScreen(): JSX.Element {
  const navigation = useNavigation<NavigationProp>();
  const route = useRoute<RouteProps>();
  const { state, actions } = useApp();
  const isOnboarding = route.name === 'FamilyContext' && !state.user;
  
  const [familyInfo, setFamilyInfo] = useState({
    ownerName: '',
    familyMembers: '',
  });

  useEffect(() => {
    if (state.user) {
      setFamilyInfo({
        ownerName: state.user.name,
        familyMembers: state.user.familyMembers?.join(', ') || '',
      });
    }
  }, [state.user]);

  const handleSave = () => {
    if (!familyInfo.ownerName) return;

    // Save user data
    actions.setUser({
      id: state.user?.id || Date.now().toString(),
      name: familyInfo.ownerName,
      familyMembers: familyInfo.familyMembers
        .split(',')
        .map(name => name.trim())
        .filter(Boolean),
    });

    if (isOnboarding) {
      navigation.navigate('PetManagement', { fromOnboarding: true });
    } else {
      navigation.goBack();
    }
  };

  return (
    <ScrollView style={styles.container}>
      {isOnboarding && (
        <>
          <View style={styles.progressBar}>
            <View style={[styles.progressFill, { width: '33%' }]} />
          </View>

          <Text style={styles.title}>First, Tell Us About Your Magical Circle!</Text>
          <Text style={styles.subtitle}>
            This helps us understand who shares in the magic of your pets' daily life
          </Text>
        </>
      )}

      <View style={styles.inputGroup}>
        <Text style={styles.label}>What shall we call you?</Text>
        <TextInput
          style={styles.input}
          value={familyInfo.ownerName}
          onChangeText={(text) => setFamilyInfo(prev => ({ ...prev, ownerName: text }))}
          placeholder="Enter your name"
        />
      </View>

      <View style={styles.inputGroup}>
        <Text style={styles.label}>Who else shares in the magic? (optional)</Text>
        <Text style={styles.hint}>Other humans who bring joy to your pets' lives</Text>
        <TextInput
          style={styles.input}
          value={familyInfo.familyMembers}
          onChangeText={(text) => setFamilyInfo(prev => ({ ...prev, familyMembers: text }))}
          placeholder="Names, separated by commas"
        />
      </View>

      {isOnboarding && (
        <Text style={styles.disclaimer}>
          Next, we'll create profiles for your magical companions!
        </Text>
      )}

      <Pressable 
        style={[
          styles.button,
          !familyInfo.ownerName && styles.buttonDisabled
        ]}
        onPress={handleSave}
      >
        <Text style={styles.buttonText}>
          {isOnboarding ? 'Next: Add Your Pets' : 'Save Changes'}
        </Text>
      </Pressable>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    padding: 20,
  },
  progressBar: {
    height: 4,
    backgroundColor: '#E0E0E0',
    borderRadius: 2,
    marginBottom: 30,
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#007AFF',
    borderRadius: 2,
  },
  title: {
    fontSize: 24,
    fontWeight: '600',
    marginBottom: 10,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 30,
    textAlign: 'center',
  },
  inputGroup: {
    marginBottom: 24,
  },
  label: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 4,
    color: '#333',
  },
  hint: {
    fontSize: 14,
    color: '#666',
    marginBottom: 8,
    fontStyle: 'italic',
  },
  input: {
    borderWidth: 1,
    borderColor: '#E0E0E0',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
  },
  disclaimer: {
    textAlign: 'center',
    color: '#666',
    fontStyle: 'italic',
    marginTop: 20,
    marginBottom: 20,
  },
  button: {
    backgroundColor: '#007AFF',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
    marginVertical: 20,
  },
  buttonDisabled: {
    backgroundColor: '#A0A0A0',
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
});

export default FamilyContextScreen;

================================================================================
File: C:\Users\admloc\Desktop\KWAB\PetMindReader\src\screens\onboarding\PetDetailsScreen.tsx
================================================================================

// src/screens/onboarding/PetDetailsScreen.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { View, Text, TextInput, StyleSheet, Pressable, ScrollView, Alert } from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { useApp } from '../../contexts/AppContext';

interface PersonalityTrait {
  id: string;
  label: string;
  selected: boolean;
}

const DEFAULT_TRAITS: PersonalityTrait[] = [
  { id: '1', label: 'Loving', selected: false },
  { id: '2', label: 'Independent', selected: false },
  { id: '3', label: 'Playful', selected: false },
  { id: '4', label: 'Shy', selected: false },
  { id: '5', label: 'Energetic', selected: false },
  { id: '6', label: 'Lazy', selected: false },
  { id: '7', label: 'Curious', selected: false },
  { id: '8', label: 'Mischievous', selected: false },
];

function PetDetailsScreen(): JSX.Element {
  const navigation = useNavigation();
  const route = useRoute();
  const { state, actions } = useApp();
  const params = route.params as { petId: string | null; fromOnboarding?: boolean };
  const editingPet = params.petId ? state.pets.find(p => p.id === params.petId) : null;
  
  const [petInfo, setPetInfo] = useState({
    name: '',
    type: '',
    breed: '',
    customTraits: '',
    quirks: '',
    favoriteThings: '',
  });

  const [suggestedTraits, setSuggestedTraits] = useState<PersonalityTrait[]>(DEFAULT_TRAITS);
  const [isSaving, setIsSaving] = useState(false);

  useEffect(() => {
    if (editingPet) {
      setPetInfo({
        name: editingPet.name,
        type: editingPet.type,
        breed: editingPet.breed || '',
        customTraits: editingPet.traits?.custom.join(', ') || '',
        quirks: editingPet.quirks || '',
        favoriteThings: editingPet.favoriteThings || '',
      });

      if (editingPet.traits?.suggested) {
        setSuggestedTraits(DEFAULT_TRAITS.map(trait => ({
          ...trait,
          selected: editingPet.traits!.suggested.includes(trait.label),
        })));
      }
    }
  }, [editingPet]);

  const toggleTrait = useCallback((id: string) => {
    setSuggestedTraits(prev => prev.map(trait =>
      trait.id === id ? { ...trait, selected: !trait.selected } : trait
    ));
  }, []);

  const validatePetInfo = useCallback(() => {
    if (!petInfo.name.trim()) {
      Alert.alert('Missing Information', 'Please enter your pet\'s name.');
      return false;
    }
    if (!petInfo.type.trim()) {
      Alert.alert('Missing Information', 'Please specify what kind of pet they are.');
      return false;
    }
    return true;
  }, [petInfo]);

  const handleSave = useCallback(async () => {
    if (!validatePetInfo() || isSaving) return;

    try {
      setIsSaving(true);

      const pet = {
        id: params.petId || `pet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: petInfo.name.trim(),
        type: petInfo.type.trim(),
        breed: petInfo.breed.trim() || undefined,
        traits: {
          suggested: suggestedTraits.filter(t => t.selected).map(t => t.label),
          custom: petInfo.customTraits.split(',').map(t => t.trim()).filter(Boolean),
        },
        quirks: petInfo.quirks.trim() || undefined,
        favoriteThings: petInfo.favoriteThings.trim() || undefined,
      };
      
      if (params.petId) {
        await actions.updatePet(pet);
      } else {
        await actions.addPet(pet);
      }

      navigation.goBack();
    } catch (error) {
      console.error('Error saving pet:', error);
      Alert.alert(
        'Error',
        'There was a problem saving your pet\'s information. Please try again.'
      );
    } finally {
      setIsSaving(false);
    }
  }, [petInfo, suggestedTraits, params.petId, actions, navigation, validatePetInfo, isSaving]);

  const handleDelete = useCallback(() => {
    if (!params.petId) return;

    Alert.alert(
      'Delete Pet',
      `Are you sure you want to delete ${petInfo.name}'s profile? This cannot be undone.`,
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          onPress: async () => {
            try {
              await actions.deletePet(params.petId!);
              navigation.goBack();
            } catch (error) {
              console.error('Error deleting pet:', error);
              Alert.alert('Error', 'Failed to delete pet. Please try again.');
            }
          },
          style: 'destructive'
        }
      ]
    );
  }, [params.petId, petInfo.name, actions, navigation]);

  return (
    <ScrollView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>
          {editingPet ? `Edit ${petInfo.name}'s Profile` : 'Add a New Pet'}
        </Text>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Basic Information</Text>
        
        <View style={styles.inputGroup}>
          <Text style={styles.label}>What's their name?</Text>
          <TextInput
            style={styles.input}
            value={petInfo.name}
            onChangeText={(text) => setPetInfo(prev => ({ ...prev, name: text }))}
            placeholder="Enter pet's name"
            editable={!isSaving}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>What kind of pet are they?</Text>
          <TextInput
            style={styles.input}
            value={petInfo.type}
            onChangeText={(text) => setPetInfo(prev => ({ ...prev, type: text }))}
            placeholder="e.g., Cat, Dog, etc."
            editable={!isSaving}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Breed (optional)</Text>
          <TextInput
            style={styles.input}
            value={petInfo.breed}
            onChangeText={(text) => setPetInfo(prev => ({ ...prev, breed: text }))}
            placeholder="e.g., Persian, Golden Retriever"
            editable={!isSaving}
          />
        </View>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Personality & Preferences</Text>
        
        <Text style={styles.label}>Personality Traits</Text>
        <Text style={styles.hint}>Tap any that fit:</Text>
        <View style={styles.traitsContainer}>
          {suggestedTraits.map(trait => (
            <Pressable
              key={trait.id}
              style={[
                styles.traitButton, 
                trait.selected && styles.traitSelected,
                isSaving && styles.disabled
              ]}
              onPress={() => toggleTrait(trait.id)}
              disabled={isSaving}
            >
              <Text style={[
                styles.traitText, 
                trait.selected && styles.traitTextSelected,
                isSaving && styles.disabledText
              ]}>
                {trait.label}
              </Text>
            </Pressable>
          ))}
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Additional Traits</Text>
          <Text style={styles.hint}>Add your own traits, separated by commas</Text>
          <TextInput
            style={styles.input}
            value={petInfo.customTraits}
            onChangeText={(text) => setPetInfo(prev => ({ ...prev, customTraits: text }))}
            placeholder="e.g., dramatic, food-obsessed, gentle"
            multiline
            editable={!isSaving}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>What makes them unique?</Text>
          <Text style={styles.hint}>Any quirks or special behaviors?</Text>
          <TextInput
            style={[styles.input, styles.multilineInput]}
            value={petInfo.quirks}
            onChangeText={(text) => setPetInfo(prev => ({ ...prev, quirks: text }))}
            placeholder="e.g., always sleeps in the sink, follows me to the bathroom"
            multiline
            numberOfLines={3}
            editable={!isSaving}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>What do they love?</Text>
          <Text style={styles.hint}>Favorite activities, treats, or spots?</Text>
          <TextInput
            style={[styles.input, styles.multilineInput]}
            value={petInfo.favoriteThings}
            onChangeText={(text) => setPetInfo(prev => ({ ...prev, favoriteThings: text }))}
            placeholder="e.g., chasing laser dots, belly rubs, tuna treats"
            multiline
            numberOfLines={3}
            editable={!isSaving}
          />
        </View>
      </View>

      <View style={styles.buttonContainer}>
        <Pressable 
          style={[
            styles.button,
            (!petInfo.name || !petInfo.type || isSaving) && styles.buttonDisabled
          ]}
          onPress={handleSave}
          disabled={isSaving}
        >
          <Text style={styles.buttonText}>
            {isSaving ? 'Saving...' : (editingPet ? 'Save Changes' : 'Add Pet')}
          </Text>
        </Pressable>

        {editingPet && (
          <Pressable 
            style={[styles.deleteButton, isSaving && styles.buttonDisabled]}
            onPress={handleDelete}
            disabled={isSaving}
          >
            <Text style={styles.deleteButtonText}>Delete Pet</Text>
          </Pressable>
        )}
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  header: {
    padding: 20,
    paddingBottom: 10,
  },
  title: {
    fontSize: 24,
    fontWeight: '600',
    textAlign: 'center',
  },
  section: {
    padding: 20,
    paddingTop: 0,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: '600',
    marginBottom: 16,
    color: '#007AFF',
  },
  inputGroup: {
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 4,
    color: '#333',
  },
  hint: {
    fontSize: 14,
    color: '#666',
    marginBottom: 8,
    fontStyle: 'italic',
  },
  input: {
    borderWidth: 1,
    borderColor: '#E0E0E0',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  multilineInput: {
    minHeight: 80,
    textAlignVertical: 'top',
  },
  traitsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    marginBottom: 16,
  },
  traitButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#007AFF',
  },
  traitSelected: {
    backgroundColor: '#007AFF',
  },
  traitText: {
    color: '#007AFF',
    fontSize: 16,
  },
  traitTextSelected: {
    color: '#fff',
  },
  buttonContainer: {
    padding: 20,
  },
  button: {
    backgroundColor: '#007AFF',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  buttonDisabled: {
    backgroundColor: '#A0A0A0',
  },
  deleteButton: {
    backgroundColor: '#FF3B30',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
    marginTop: 12,
  },
  deleteButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
  disabled: {
    opacity: 0.5,
  },
  disabledText: {
    opacity: 0.5,
  },
});

export default PetDetailsScreen;

================================================================================
File: C:\Users\admloc\Desktop\KWAB\PetMindReader\src\screens\onboarding\PetManagementScreen.tsx
================================================================================

// src/screens/onboarding/PetManagementScreen.tsx
import React, { useCallback } from 'react';
import { View, Text, StyleSheet, Pressable, FlatList, Alert } from 'react-native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { RouteProp } from '@react-navigation/native';
import { Swipeable } from 'react-native-gesture-handler';
import { useApp } from '../../contexts/AppContext';
import { MainStackParamList, OnboardingStackParamList } from '../../navigation';
import type { Pet } from '../../contexts/AppContext';

type CombinedParamList = MainStackParamList & OnboardingStackParamList;

type NavigationProp = NativeStackNavigationProp<CombinedParamList, 'PetManagement'>;
type RouteProps = RouteProp<CombinedParamList, 'PetManagement'>;

interface Props {
  navigation: NavigationProp;
  route: RouteProps;
}

function PetManagementScreen({ navigation, route }: Props): JSX.Element {
  const { state, actions } = useApp();
  const { pets } = state;
  const isOnboarding = Boolean(route.params?.fromOnboarding);

  const handleAddPet = useCallback(() => {
    navigation.navigate('PetDetails', { 
      petId: null,
      fromOnboarding: isOnboarding 
    });
  }, [navigation, isOnboarding]);

  const handleEditPet = useCallback((petId: string) => {
    navigation.navigate('PetDetails', { 
      petId,
      fromOnboarding: isOnboarding 
    });
  }, [navigation, isOnboarding]);

  const handleComplete = useCallback(() => {
    if (isOnboarding) {
      // When in onboarding, navigate to Home screen
      navigation.reset({
        index: 0,
        routes: [{ name: 'Home' }],
      });
    } else {
      navigation.goBack();
    }
  }, [navigation, isOnboarding]);

  const handleDeletePet = useCallback((petId: string, petName: string) => {
    Alert.alert(
      'Remove Companion',
      `Are you sure you want to remove ${petName} from your magical circle?`,
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Remove',
          onPress: () => actions.deletePet(petId),
          style: 'destructive'
        }
      ]
    );
  }, [actions]);

  const renderRightActions = useCallback((petId: string, petName: string) => {
    return (
      <Pressable 
        style={styles.deleteAction}
        onPress={() => handleDeletePet(petId, petName)}
      >
        <Text style={styles.deleteActionText}>Remove</Text>
      </Pressable>
    );
  }, [handleDeletePet]);

  const renderPetCard = useCallback(({ item: pet }: { item: Pet }) => (
    <Swipeable
      renderRightActions={() => renderRightActions(pet.id, pet.name)}
      rightThreshold={40}
    >
      <Pressable
        style={styles.petCard}
        onPress={() => handleEditPet(pet.id)}
      >
        <View style={styles.petInfo}>
          <Text style={styles.petName}>{pet.name}</Text>
          <Text style={styles.petType}>
            {pet.type}{pet.breed ? ` • ${pet.breed}` : ''}
          </Text>
          {pet.traits && (
            <Text style={styles.petTraits}>
              {[...pet.traits.suggested, ...pet.traits.custom].slice(0, 3).join(', ')}
              {pet.traits.suggested.length + pet.traits.custom.length > 3 ? '...' : ''}
            </Text>
          )}
        </View>
        <Text style={styles.editText}>Edit</Text>
      </Pressable>
    </Swipeable>
  ), [handleEditPet, renderRightActions]);

  const EmptyState = useCallback(() => (
    <View style={styles.emptyState}>
      <Text style={styles.emptyStateText}>
        No companions added yet. Tap the button below to add your first magical friend!
      </Text>
    </View>
  ), []);

  return (
    <View style={styles.container}>
      {isOnboarding && (
        <View style={styles.progressBar}>
          <View style={[styles.progressFill, { width: '66%' }]} />
        </View>
      )}

      <View style={styles.header}>
        <Text style={styles.title}>
          {isOnboarding ? 'Your Magical Companions' : 'Manage Your Companions'}
        </Text>
        {isOnboarding && (
          <Text style={styles.subtitle}>
            Add profiles for all your furry friends!
          </Text>
        )}
      </View>

      <FlatList
        data={pets}
        renderItem={renderPetCard}
        keyExtractor={pet => pet.id}
        extraData={pets.length}
        contentContainerStyle={styles.petList}
        ListEmptyComponent={EmptyState}
      />

      <View style={styles.buttonContainer}>
        <Pressable 
          style={styles.addButton}
          onPress={handleAddPet}
        >
          <Text style={styles.buttonText}>
            {pets.length === 0 ? 'Add Your First Companion' : 'Add Another Companion'}
          </Text>
        </Pressable>

        {(pets.length > 0 || !isOnboarding) && (
          <Pressable 
            style={[styles.completeButton, !isOnboarding && styles.doneButton]}
            onPress={handleComplete}
          >
            <Text style={styles.buttonText}>
              {isOnboarding ? 'Complete Setup' : 'Done'}
            </Text>
          </Pressable>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    padding: 20,
  },
  progressBar: {
    height: 4,
    backgroundColor: '#E0E0E0',
    borderRadius: 2,
    marginBottom: 30,
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#007AFF',
    borderRadius: 2,
  },
  header: {
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: '600',
    textAlign: 'center',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  petList: {
    flexGrow: 1,
  },
  petCard: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#f8f9fa',
    borderRadius: 12,
    marginBottom: 12,
  },
  petInfo: {
    flex: 1,
  },
  petName: {
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 4,
  },
  petType: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  petTraits: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
  },
  editText: {
    color: '#007AFF',
    fontSize: 16,
  },
  deleteAction: {
    backgroundColor: '#FF3B30',
    justifyContent: 'center',
    alignItems: 'center',
    width: 80,
    height: '100%',
  },
  deleteActionText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 16,
  },
  emptyState: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyStateText: {
    textAlign: 'center',
    color: '#666',
    fontSize: 16,
  },
  buttonContainer: {
    gap: 12,
  },
  addButton: {
    backgroundColor: '#007AFF',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  completeButton: {
    backgroundColor: '#34C759',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  doneButton: {
    backgroundColor: '#007AFF',
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
});

export default PetManagementScreen;

================================================================================
File: C:\Users\admloc\Desktop\KWAB\PetMindReader\src\screens\onboarding\WelcomeScreen.tsx
================================================================================

// src/screens/onboarding/WelcomeScreen.tsx
import React from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import type { OnboardingStackParamList } from '../../navigation';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';

type NavigationProp = NativeStackNavigationProp<OnboardingStackParamList, 'Welcome'>;

function WelcomeScreen(): JSX.Element {
  const navigation = useNavigation<NavigationProp>();

  return (
    <View style={styles.container}>
      <View style={styles.contentContainer}>
        <Text style={styles.title}>Welcome to Pet Thoughts!</Text>
        <Text style={styles.subtitle}>
          Ever wondered what your pets are thinking? Let's get started and find out together!
        </Text>
        <Text style={styles.description}>
          We'll start by getting to know you and your family, then learn about all your wonderful pets.
        </Text>
      </View>
      
      <Pressable 
        style={styles.button}
        onPress={() => navigation.navigate('FamilyContext')}
      >
        <Text style={styles.buttonText}>Let's Begin!</Text>
      </Pressable>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    padding: 20,
    justifyContent: 'space-between',
  },
  contentContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    gap: 20,
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 18,
    textAlign: 'center',
    color: '#666',
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    color: '#666',
    paddingHorizontal: 20,
  },
  button: {
    backgroundColor: '#007AFF',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '600',
  },
});

export default WelcomeScreen;
